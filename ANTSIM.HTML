<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2개 등방성 안테나 배열 방사패턴 시뮬레이터 (위상 제어)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f7f6;
            color: #333;
            /* overflow: hidden; 속성 제거: 필요 시 스크롤바 자동 생성 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* 상단부터 내용 배치 */
            min-height: 100vh; /* 뷰포트 전체 높이 사용 */
            padding-bottom: 50px; /* 하단 여백 추가 (스크롤 시 내용 잘림 방지) */
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* justify-content: center; 제거: 스크롤 영역 확보 */
            padding: 20px;
            max-width: 900px;
            width: 100%;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.2em;
        }
        #info-panel {
            background-color: #e8f5e9;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.1em;
            width: 80%;
            max-width: 600px;
        }
        #info-panel p {
            margin: 5px 0;
        }
        #info-panel strong {
            color: #4CAF50;
        }
        #controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .control-group {
            text-align: left;
        }
        .control-group label {
            display: block;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        .control-group input[type="number"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 100px;
            text-align: center;
            font-size: 1em;
        }
        .value-display {
            font-weight: bold;
            color: #1976D2;
            margin-left: 5px;
        }
        #pattern-container { 
            width: 1000px; 
            height: 1000px;
            background-color: #fcfcfc;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden; /* SVG 캔버스 자체는 스크롤되지 않도록 hidden 유지 */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            margin-top: 20px;
            /* min-height를 100vh로 설정하면 패턴 컨테이너가 잘릴 수 있으므로, flex-start로 변경 */
        }
        #patternChart {
            width: 100%;
            height: 100%;
        }
        /* SVG 요소 스타일 */
        .polar-grid-circle {
            fill: none;
            stroke: #ccc;
            stroke-width: 0.8;
            stroke-dasharray: 2 2;
        }
        .polar-grid-line {
            fill: none; /* 추가: 선이 채워지지 않도록 */
            stroke: #ccc;
            stroke-width: 0.8;
            stroke-dasharray: 2 2;
        }
        .center-dot {
            fill: #555;
        }
        .pattern-path {
            fill: none;
            stroke: #4CAF50;
            stroke-width: 3;
        }
        .antenna-element {
            fill: #FF5722;
            stroke: #CD3300;
            stroke-width: 1;
        }
        .axis-label {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12px;
            fill: #555;
            text-anchor: middle;
        }
        .magnitude-label {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 10px;
            fill: #777;
            text-anchor: middle;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>2개 등방성 안테나 배열 방사패턴 시뮬레이터</h1>

        <div id="info-panel">
            <p><strong>2개 등방성 안테나 배열</strong>은 안테나 간격과 위상 차이에 따라 다양한 로브 패턴을 가집니다.</p>
            <p>안테나 배열은 X축에 위치하며, 안테나 1은 기준(0 위상), 안테나 2는 상대 위상을 가집니다.</p>
            <p>이득: <span id="display-gain"></span> dB (선형: <span id="display-linear-gain"></span>배)</p>
            <p>파장: <span id="display-wavelength"></span> m</p>

            <div id="controls">
                <div class="control-group">
                    <label for="gain-input">개별 안테나 이득 (dB):</label>
                    <input type="number" id="gain-input" value="0.0" step="0.1" min="-10.0" max="10.0">
                    <span id="gain-value-display"></span>
                </div>
                <div class="control-group">
                    <label for="spacing-input">안테나 간격 (Degree):</label>
                    <input type="number" id="spacing-input" value="180" step="10" min="0" max="720">
                    <span id="spacing-value-display"></span>
                    <p style="font-size:0.85em; color:#666; margin-top:5px;">
                        (예: 180 Deg = 0.5 파장 간격)
                    </p>
                </div>
                <div class="control-group">
                    <label for="phase-input">안테나 2 위상 차이 (Degree):</label>
                    <input type="number" id="phase-input" value="0" step="10" min="-360" max="360">
                    <span id="phase-value-display"></span>
                    <p style="font-size:0.85em; color:#666; margin-top:5px;">
                        (안테나 1 기준. 0이면 동위상)
                    </p>
                </div>
            </div>
        </div>

        <div id="pattern-container">
            <svg id="patternChart" viewBox="0 0 1000 1000"></svg>
        </div>
    </div>

    <script>
        // SVG 크기 및 중심 (2배 확대)
        const SVG_VIEWBOX_SIZE = 1000; 
        const SVG_CENTER = SVG_VIEWBOX_SIZE / 2; 
        const MAX_RADIUS = SVG_CENTER * 0.8; 

        // 가상 파장 (주파수 300 MHz 기준, 약 1m 파장)
        const FREQUENCY_HZ = 300 * 10**6; 
        const C = 299792458; 
        const WAVELENGTH_M = C / FREQUENCY_HZ; 

        // HTML 요소 참조
        const displayGainElement = document.getElementById('display-gain');
        const displayLinearGainElement = document.getElementById('display-linear-gain');
        const displayWavelengthElement = document.getElementById('display-wavelength');
        const gainInputElement = document.getElementById('gain-input');
        const gainValueDisplayElement = document.getElementById('gain-value-display');
        const spacingInputElement = document.getElementById('spacing-input');
        const spacingValueDisplayElement = document.getElementById('spacing-value-display');
        const phaseInputElement = document.getElementById('phase-input');
        const phaseValueDisplayElement = document.getElementById('phase-value-display');
        const patternChart = document.getElementById('patternChart');

        let patternPath; 
        let antennaElements = []; 

        // 초기화 함수
        function init() {
            displayWavelengthElement.textContent = WAVELENGTH_M.toFixed(3); 

            drawPolarGrid(); 
            
            patternPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
            patternPath.classList.add("pattern-path");
            patternChart.appendChild(patternPath);

            // 안테나 소자 2개 초기 생성
            const antennaRadius = 3 * (SVG_VIEWBOX_SIZE / 500); // SVG 크기에 맞춰 반지름도 조정 (이전 500px 기준)
            for (let i = 0; i < 2; i++) {
                const antennaDot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                antennaDot.setAttribute("r", antennaRadius);
                antennaDot.classList.add("antenna-element");
                patternChart.appendChild(antennaDot);
                antennaElements.push(antennaDot);
            }

            // 이벤트 리스너
            gainInputElement.addEventListener('input', updatePattern);
            spacingInputElement.addEventListener('input', updatePattern);
            phaseInputElement.addEventListener('input', updatePattern);

            // 초기 패턴 업데이트
            updatePattern(); 
        }

        // 극좌표 그리드 그리기 함수
        function drawPolarGrid() {
            patternChart.innerHTML = ''; 

            patternChart.innerHTML += `<circle cx="${SVG_CENTER}" cy="${SVG_CENTER}" r="2" class="center-dot" />`;

            // 동심원 (크기 눈금)
            const numCircles = 4;
            for (let i = 1; i <= numCircles; i++) {
                const r = (MAX_RADIUS / numCircles) * i;
                patternChart.innerHTML += `<circle cx="${SVG_CENTER}" cy="${SVG_CENTER}" r="${r}" class="polar-grid-circle" />`;
                const gainAtRadius = (i / numCircles) * 1.0; 
                // 레이블 위치 조정 (SVG_VIEWBOX_SIZE가 커졌으므로 레이블 오프셋도 조정)
                patternChart.innerHTML += `<text x="${SVG_CENTER + r + (SVG_VIEWBOX_SIZE * 0.02)}" y="${SVG_CENTER + (SVG_VIEWBOX_SIZE * 0.01)}" class="magnitude-label" text-anchor="middle">${(gainAtRadius * 2).toFixed(1)}x</text>`; 
            }

            // 방사선 (각도 눈금)
            const numLines = 12; // 30도 간격
            for (let i = 0; i < numLines; i++) {
                const angle = i * (360 / numLines);
                const angleRad = angle * Math.PI / 180;
                const x1 = SVG_CENTER;
                const y1 = SVG_CENTER;
                const x2 = SVG_CENTER + MAX_RADIUS * Math.cos(angleRad);
                const y2 = SVG_CENTER + MAX_RADIUS * Math.sin(angleRad);
                patternChart.innerHTML += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" class="polar-grid-line" />`;
                
                // 각도 레이블 위치 조정
                const labelOffset = SVG_VIEWBOX_SIZE * 0.08; /* 이전 40px */
                const labelX = SVG_CENTER + (MAX_RADIUS + labelOffset) * Math.cos(angleRad);
                const labelY = SVG_CENTER + (MAX_RADIUS + labelOffset) * Math.sin(angleRad);
                patternChart.innerHTML += `<text x="${labelX}" y="${labelY}" class="axis-label">${angle}°</text>`;
            }
        }

        // 패턴 업데이트 함수
        function updatePattern() {
            let gainDb = parseFloat(gainInputElement.value);
            if (isNaN(gainDb)) {
                gainDb = 0.0;
                gainInputElement.value = 0.0;
            }
            
            const linearGain = Math.pow(10, gainDb / 10); 

            let spacingDeg = parseFloat(spacingInputElement.value);
            if (isNaN(spacingDeg)) {
                spacingDeg = 0;
                spacingInputElement.value = 0;
            }
            // Degree 간격을 파장 단위의 물리적 거리로 변환
            const d_meters = (spacingDeg / 360) * WAVELENGTH_M; 
            const k = (2 * Math.PI) / WAVELENGTH_M; // 파수

            let phaseDeg = parseFloat(phaseInputElement.value); // 위상 차이 입력
            if (isNaN(phaseDeg)) {
                phaseDeg = 0;
                phaseInputElement.value = 0;
            }
            const alphaRad = phaseDeg * Math.PI / 180; // 위상 차이 (라디안)

            let pathData = "M"; 

            // 안테나 소자 위치 업데이트 (X축 상에 -d/2, d/2 위치)
            // SVG 스케일에 맞춰 위치 조정 (MAX_RADIUS를 기준으로 파장 비례)
            const antennaOffsetMeters = d_meters / 2; // 각 안테나가 중심에서 떨어진 물리적 거리
            // 스케일 비율 조정: 1파장 간격 (360 Degree)일 때 MAX_RADIUS가 되도록 (X축 범위 전체)
            const scaleRatio = MAX_RADIUS / (WAVELENGTH_M * (SVG_VIEWBOX_SIZE / (MAX_RADIUS*2) * 0.5)); // SVG 좌표계에 맞춤
            
            // 이 스케일 비율은 원점에서 안테나가 얼마나 멀리 떨어져 그려지는지 제어합니다.
            // 안테나가 SVG 캔버스 중앙에 적절히 표시되도록 조정했습니다.
            // MAX_RADIUS/1000 * SVG_VIEWBOX_SIZE / (WAVELENGTH_M * 2) // 간격이 너무 넓어서 패턴 바깥으로 나가는 것을 방지
            const antennaDrawingScale = (MAX_RADIUS / (WAVELENGTH_M * 2)); // 1파장이 그려질 때의 SVG 스케일 (임의 조정)

            const antenna1_x_svg = SVG_CENTER - antennaOffsetMeters * antennaDrawingScale;
            const antenna2_x_svg = SVG_CENTER + antennaOffsetMeters * antennaDrawingScale;

            antennaElements[0].setAttribute("cx", antenna1_x_svg);
            antennaElements[0].setAttribute("cy", SVG_CENTER);
            antennaElements[1].setAttribute("cx", antenna2_x_svg);
            antennaElements[1].setAttribute("cy", SVG_CENTER);


            // 360도 전체 각도에 대해 패턴 계산 및 그리기
            for (let angle = 0; angle <= 360; angle += 1) { 
                const angleRad = angle * Math.PI / 180; 

                // 2개 등방성 안테나 배열 인자 AF = |2 * cos( (k * d / 2) * cos(theta) + alpha/2 )|
                const AF_phase_term = (k * d_meters / 2) * Math.cos(angleRad) + (alphaRad / 2);
                const arrayFactorMagnitude = Math.abs(2 * Math.cos(AF_phase_term));
                
                // 최종 패턴 반지름 (개별 선형 이득 * 배열 인자 * 기준 스케일)
                // baseScaleFactor는 선형 이득 1일 때 AF의 최대값 2를 고려하여 MAX_RADIUS의 절반을 채우도록 함 (MAX_RADIUS/2 = 0dB gain)
                const baseScaleFactor = (MAX_RADIUS / 2); 
                const effectivePatternRadius = linearGain * arrayFactorMagnitude * baseScaleFactor; 

                const clampedPatternRadius = Math.max(0, effectivePatternRadius);

                // 극좌표 (반지름, 각도)를 데카르트 좌표 (x, y)로 변환
                const x = SVG_CENTER + clampedPatternRadius * Math.cos(angleRad);
                const y = SVG_CENTER + clampedPatternRadius * Math.sin(angleRad);

                if (angle === 0) {
                    pathData += `${x},${y}`; 
                } else {
                    pathData += ` L${x},${y}`; 
                }
            }
            pathData += " Z"; 

            patternPath.setAttribute("d", pathData); 

            // 정보 패널 업데이트
            displayGainElement.textContent = gainDb.toFixed(1);
            displayLinearGainElement.textContent = linearGain.toFixed(2);
            gainValueDisplayElement.textContent = `(현재: ${gainDb.toFixed(1)} dB)`;
            spacingValueDisplayElement.textContent = `(${spacingDeg.toFixed(0)} Degree)`;
            phaseValueDisplayElement.textContent = `(${phaseDeg.toFixed(0)} Degree)`;
        }

        // 페이지 로드 시 초기화 시작
        init();
    </script>
</body>
</html>