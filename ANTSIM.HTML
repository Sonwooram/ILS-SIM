<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>어레이 안테나 방사패턴 시뮬레이터</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f4f9;
        }
        h1 {
            color: #333;
        }
        .container {
            display: flex;
            width: 100%;
            max-width: 1200px;
            gap: 20px;
            margin-top: 20px;
        }
        .controls {
            flex: 1;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .visualization {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .canvas-container {
            display: flex;
            gap: 20px;
        }
        .canvas-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .canvas-wrapper h3 {
            margin-top: 0;
            color: #555;
        }
        .controls h2, .visualization h2 {
            margin-top: 0;
            color: #555;
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .input-group input[type="range"] {
            width: 100%;
        }
        .input-group input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .current-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        .current-table th, .current-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        .current-table th {
            background-color: #f2f2f2;
        }
        canvas {
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            cursor: crosshair;
        }
        #analysis-result {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9f4;
            border-radius: 4px;
        }
        #analysis-result p {
            margin: 5px 0;
        }
        #selectedPointInput {
            width: 100px;
        }
        .math-expr {
            font-family: 'Times New Roman', serif;
            font-size: 1.2em;
        }
    </style>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
</head>
<body>

    <h1>어레이 안테나 방사패턴 시뮬레이터</h1>

    <div class="container">
        <div class="controls">
            <h2>설정</h2>
            <div class="input-group">
                <label for="antennaCount">안테나 개수 (N): <span id="antennaCountValue">5</span></label>
                <input type="range" id="antennaCount" min="1" max="20" value="5">
            </div>
            <div class="input-group">
                <label for="phaseDifference">안테나 간 위상차 (β) [°]:</label>
                <input type="number" id="phaseDifference" value="0" min="-360" max="360" step="1">
            </div>
            <div class="input-group">
                <label for="frequency">주파수 (f) [MHz]:</label>
                <input type="number" id="frequency" value="300" min="1">
            </div>
            <div class="info">
                <p>계산된 안테나 간 거리 (d): <span id="calculatedDistance">...</span> m</p>
                <p>파장 (λ): <span id="wavelength">...</span> m</p>
            </div>
            <h3>안테나별 전류 (I)</h3>
            <table class="current-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>크기</th>
                        <th>위상 [°]</th>
                    </tr>
                </thead>
                <tbody id="currentTableBody">
                </tbody>
            </table>
        </div>

        <div class="visualization">
            <h2>결과 시각화</h2>
            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <h3>방사패턴</h3>
                    <canvas id="radiationPatternCanvas" width="600" height="600"></canvas>
                </div>
                <div class="canvas-wrapper">
                    <h3>전계 벡터 합</h3>
                    <canvas id="vectorSumCanvas" width="600" height="600"></canvas>
                </div>
            </div>
            <div id="analysis-result">
                <h3>선택 지점 분석 (수신점 P)</h3>
                <p>
                    각도 (θ): 
                    <input type="number" id="selectedPointInput" value="0" min="0" max="360" step="1">
                    ° <button id="updatePointBtn">적용</button>
                </p>
                <p>총 전계강도 (복소수 합): <span id="totalEfield">0</span></p>
                <p>총 전계강도 (실수부만 합): <span id="totalEfieldReal">0</span></p>
                <div id="individualEfields"></div>
            </div>
        </div>
    </div>

    <script>
        const radiationPatternCanvas = document.getElementById('radiationPatternCanvas');
        const radiationPatternCtx = radiationPatternCanvas.getContext('2d');
        const vectorSumCanvas = document.getElementById('vectorSumCanvas');
        const vectorSumCtx = vectorSumCanvas.getContext('2d');

        const c = 299792458; // 빛의 속도 (m/s)

        const antennaCountInput = document.getElementById('antennaCount');
        const phaseDifferenceInput = document.getElementById('phaseDifference');
        const frequencyInput = document.getElementById('frequency');
        const currentTableBody = document.getElementById('currentTableBody');

        const antennaCountValue = document.getElementById('antennaCountValue');
        const calculatedDistanceSpan = document.getElementById('calculatedDistance');
        const wavelengthSpan = document.getElementById('wavelength');
        const totalEfieldSpan = document.getElementById('totalEfield');
        const totalEfieldRealSpan = document.getElementById('totalEfieldReal');
        const individualEfieldsDiv = document.getElementById('individualEfields');
        const selectedPointInput = document.getElementById('selectedPointInput');
        const updatePointBtn = document.getElementById('updatePointBtn');
        
        let selectedAngleRad = null;

        function updateCurrentTable() {
            const count = parseInt(antennaCountInput.value);
            currentTableBody.innerHTML = '';
            for (let i = 0; i < count; i++) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${i + 1}</td>
                    <td><input type="number" class="current-mag" value="1" min="0" step="0.1" data-index="${i}"></td>
                    <td><input type="number" class="current-phase" value="0" min="-360" max="360" step="1" data-index="${i}"></td>
                `;
                currentTableBody.appendChild(row);
            }
            document.querySelectorAll('.current-mag, .current-phase').forEach(input => {
                input.addEventListener('input', updatePattern);
            });
        }
        
        function drawPolarPlot(data) {
            radiationPatternCtx.clearRect(0, 0, radiationPatternCanvas.width, radiationPatternCanvas.height);
            const centerX = radiationPatternCanvas.width / 2;
            const centerY = radiationPatternCanvas.height / 2;
            const maxRadius = Math.min(centerX, centerY) * 0.8;
            const maxValue = Math.max(...data);
            
            // 극좌표 그리드 그리기
            radiationPatternCtx.strokeStyle = '#ddd';
            radiationPatternCtx.beginPath();
            radiationPatternCtx.arc(centerX, centerY, maxRadius, 0, 2 * Math.PI);
            radiationPatternCtx.stroke();
            for (let i = 0; i < 12; i++) {
                const angle = i * Math.PI / 6;
                radiationPatternCtx.beginPath();
                radiationPatternCtx.moveTo(centerX, centerY);
                radiationPatternCtx.lineTo(centerX + maxRadius * Math.cos(angle), centerY + maxRadius * Math.sin(angle));
                radiationPatternCtx.stroke();
            }
            
            // 안테나 위치 표시
            const N = parseInt(antennaCountInput.value);
            const antennaSpacing = maxRadius / (N + 1);
            for (let i = 0; i < N; i++) {
                const x = centerX;
                const y = centerY + (i - (N - 1) / 2) * antennaSpacing;
                radiationPatternCtx.beginPath();
                radiationPatternCtx.fillStyle = 'red';
                radiationPatternCtx.arc(x, y, 3, 0, 2 * Math.PI);
                radiationPatternCtx.fill();
            }

            // 방사패턴 그리기 (12시를 90도로 보이게 변환)
            if (maxValue > 0) {
                radiationPatternCtx.beginPath();
                radiationPatternCtx.strokeStyle = 'blue';
                radiationPatternCtx.lineWidth = 2;
                data.forEach((value, index) => {
                    const patternAngleRad = index * Math.PI / 180;
                    const radius = (value / maxValue) * maxRadius;
                    
                    // 각도를 12시=90도 기준으로 변환하여 그리기
                    const drawAngleRad = patternAngleRad - Math.PI / 2;
                    const x = centerX + radius * Math.cos(drawAngleRad);
                    const y = centerY + radius * Math.sin(drawAngleRad);
                    if (index === 0) {
                        radiationPatternCtx.moveTo(x, y);
                    } else {
                        radiationPatternCtx.lineTo(x, y);
                    }
                });
                radiationPatternCtx.closePath();
                radiationPatternCtx.stroke();
            }

            if (selectedAngleRad !== null) {
                drawSelectedPoint(data, selectedAngleRad);
            }
        }

        function drawSelectedPoint(patternData, angleRad) {
            const centerX = radiationPatternCanvas.width / 2;
            const centerY = radiationPatternCanvas.height / 2;
            const maxRadius = Math.min(centerX, centerY) * 0.8;
            const maxValue = Math.max(...patternData);

            if (maxValue === 0) return;

            // 입력된 각도는 3시방향 0도 기준으로
            const angleIndex = Math.round(angleRad * 180 / Math.PI) % 361;
            const patternValue = patternData[angleIndex];
            const radius = (patternValue / maxValue) * maxRadius;
            
            // 캔버스에 그릴 때는 12시가 90도가 되도록 변환
            const drawAngleRad = angleRad - Math.PI / 2;
            const x = centerX + radius * Math.cos(drawAngleRad);
            const y = centerY + radius * Math.sin(drawAngleRad);

            radiationPatternCtx.beginPath();
            radiationPatternCtx.strokeStyle = 'red';
            radiationPatternCtx.lineWidth = 2;
            radiationPatternCtx.moveTo(centerX, centerY);
            radiationPatternCtx.lineTo(x, y);
            radiationPatternCtx.stroke();

            radiationPatternCtx.beginPath();
            radiationPatternCtx.fillStyle = 'black';
            radiationPatternCtx.arc(x, y, 5, 0, 2 * Math.PI);
            radiationPatternCtx.fill();

            radiationPatternCtx.fillStyle = 'black';
            radiationPatternCtx.font = '12px Arial';
            radiationPatternCtx.fillText('수신점 P', x + 10, y);
        }

        function drawVectorSum(angleRad) {
            vectorSumCtx.clearRect(0, 0, vectorSumCanvas.width, vectorSumCanvas.height);
            const centerX = vectorSumCanvas.width / 2;
            const centerY = vectorSumCanvas.height / 2;
            
            // 그리드 및 축 그리기
            vectorSumCtx.strokeStyle = '#eee';
            vectorSumCtx.beginPath();
            vectorSumCtx.moveTo(0, centerY);
            vectorSumCtx.lineTo(vectorSumCanvas.width, centerY);
            vectorSumCtx.moveTo(centerX, 0);
            vectorSumCtx.lineTo(centerX, vectorSumCanvas.height);
            vectorSumCtx.stroke();
            
            vectorSumCtx.fillStyle = '#555';
            vectorSumCtx.font = '12px Arial';
            vectorSumCtx.fillText('실수부', vectorSumCanvas.width - 50, centerY - 10);
            vectorSumCtx.fillText('허수부', centerX + 10, 20);

            const N = parseInt(antennaCountInput.value);
            const betaDeg = parseFloat(phaseDifferenceInput.value) || 0;
            const freqHz = parseFloat(frequencyInput.value) * 1e6 || 0;

            const lambda = freqHz > 0 ? c / freqHz : 0;
            const d = (betaDeg / 360) * lambda;
            const k = freqHz > 0 ? 2 * Math.PI / lambda : 0;
            const theta = angleRad;

            let currentX = centerX;
            let currentY = centerY;
            
            // 스케일링을 위해 최대값을 찾음
            const totalMaxMag = N * parseFloat(currentTableBody.children[0].querySelector('.current-mag').value);
            const scale = Math.min(vectorSumCanvas.width, vectorSumCanvas.height) / (2.5 * totalMaxMag);

            const colors = ['#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080'];
            
            for (let n = 0; n < N; n++) {
                const currentMag = parseFloat(currentTableBody.children[n].querySelector('.current-mag').value) || 0;
                const currentPhaseRad = (parseFloat(currentTableBody.children[n].querySelector('.current-phase').value) || 0) * Math.PI / 180;
                
                const phaseTerm = k * (n - (N-1)/2) * d * Math.cos(theta) + currentPhaseRad;
                const E_real = currentMag * Math.cos(phaseTerm);
                const E_imag = currentMag * Math.sin(phaseTerm);
                
                const nextX = currentX + E_real * scale;
                const nextY = currentY - E_imag * scale;
                const vectorLabel = `E${n + 1}`;
                
                // 벡터 그리기
                vectorSumCtx.strokeStyle = colors[n % colors.length];
                vectorSumCtx.lineWidth = 2;
                vectorSumCtx.beginPath();
                vectorSumCtx.moveTo(currentX, currentY);
                vectorSumCtx.lineTo(nextX, nextY);
                vectorSumCtx.stroke();
                
                // 벡터 라벨 그리기
                const midX = (currentX + nextX) / 2;
                const midY = (currentY + nextY) / 2;
                vectorSumCtx.save();
                vectorSumCtx.fillStyle = colors[n % colors.length];
                vectorSumCtx.translate(midX, midY);
                const angle = Math.atan2(nextY - currentY, nextX - currentX);
                vectorSumCtx.rotate(angle);
                vectorSumCtx.textAlign = "center";
                vectorSumCtx.fillText(vectorLabel, 0, -5); // 벡터 위쪽으로 라벨 위치 조정
                vectorSumCtx.restore();

                // 화살표 그리기
                const arrowLength = 10;
                vectorSumCtx.fillStyle = colors[n % colors.length];
                vectorSumCtx.beginPath();
                vectorSumCtx.moveTo(nextX, nextY);
                vectorSumCtx.lineTo(nextX - arrowLength * Math.cos(angle - Math.PI / 6), nextY - arrowLength * Math.sin(angle - Math.PI / 6));
                vectorSumCtx.lineTo(nextX - arrowLength * Math.cos(angle + Math.PI / 6), nextY - arrowLength * Math.sin(angle + Math.PI / 6));
                vectorSumCtx.closePath();
                vectorSumCtx.fill();
                
                currentX = nextX;
                currentY = nextY;
            }

            // 최종 벡터 그리기
            const finalX = currentX;
            const finalY = currentY;
            vectorSumCtx.strokeStyle = 'black';
            vectorSumCtx.lineWidth = 3;
            vectorSumCtx.beginPath();
            vectorSumCtx.moveTo(centerX, centerY);
            vectorSumCtx.lineTo(finalX, finalY);
            vectorSumCtx.stroke();
            
            // 최종 벡터 라벨(Et) 그리기
            const midFinalX = (centerX + finalX) / 2;
            const midFinalY = (centerY + finalY) / 2;
            vectorSumCtx.save();
            vectorSumCtx.fillStyle = 'black';
            vectorSumCtx.translate(midFinalX, midFinalY);
            const totalAngle = Math.atan2(finalY - centerY, finalX - centerX);
            vectorSumCtx.rotate(totalAngle);
            vectorSumCtx.textAlign = "center";
            vectorSumCtx.fillText('Et', 0, -5);
            vectorSumCtx.restore();

            const totalArrowLength = 12;
            vectorSumCtx.fillStyle = 'black';
            vectorSumCtx.beginPath();
            vectorSumCtx.moveTo(finalX, finalY);
            vectorSumCtx.lineTo(finalX - totalArrowLength * Math.cos(totalAngle - Math.PI / 6), finalY - totalArrowLength * Math.sin(totalAngle - Math.PI / 6));
            vectorSumCtx.lineTo(finalX - totalArrowLength * Math.cos(totalAngle + Math.PI / 6), finalY - totalArrowLength * Math.sin(totalAngle + Math.PI / 6));
            vectorSumCtx.closePath();
            vectorSumCtx.fill();

            // 최종 벡터 각도 표시
            const angleDeg = totalAngle * 180 / Math.PI;
            const arcRadius = 50;
            const arcStart = totalAngle > 0 ? 0 : totalAngle;
            const arcEnd = totalAngle > 0 ? totalAngle : 0;
            
            vectorSumCtx.strokeStyle = '#555';
            vectorSumCtx.lineWidth = 1;
            vectorSumCtx.beginPath();
            vectorSumCtx.arc(centerX, centerY, arcRadius, arcStart, arcEnd);
            vectorSumCtx.stroke();
            
            const textAngle = totalAngle / 2;
            const textX = centerX + arcRadius * 1.2 * Math.cos(textAngle);
            const textY = centerY - arcRadius * 1.2 * Math.sin(textAngle);
            
            vectorSumCtx.fillStyle = '#555';
            vectorSumCtx.textAlign = 'center';
            vectorSumCtx.textBaseline = 'middle';
            vectorSumCtx.fillText(`${angleDeg.toFixed(1)}°`, textX, textY);
        }

        function calculateAndDrawPattern() {
            const N = parseInt(antennaCountInput.value);
            const betaDeg = parseFloat(phaseDifferenceInput.value) || 0;
            const freqHz = parseFloat(frequencyInput.value) * 1e6 || 0;

            const lambda = freqHz > 0 ? c / freqHz : 0;
            const d = (betaDeg / 360) * lambda;
            const k = freqHz > 0 ? 2 * Math.PI / lambda : 0;
            const patternData = [];

            calculatedDistanceSpan.textContent = d.toFixed(3);
            wavelengthSpan.textContent = lambda.toFixed(3);

            for (let angleDeg = 0; angleDeg <= 360; angleDeg++) {
                const theta = angleDeg * Math.PI / 180;
                let E_total_real = 0;
                let E_total_imag = 0;

                for (let n = 0; n < N; n++) {
                    const currentMag = parseFloat(currentTableBody.children[n].querySelector('.current-mag').value) || 0;
                    const currentPhaseRad = (parseFloat(currentTableBody.children[n].querySelector('.current-phase').value) || 0) * Math.PI / 180;
                    
                    const phaseTerm = k * (n - (N-1)/2) * d * Math.cos(theta) + currentPhaseRad;
                    E_total_real += currentMag * Math.cos(phaseTerm);
                    E_total_imag += currentMag * Math.sin(phaseTerm);
                }
                patternData.push(Math.sqrt(E_total_real * E_total_real + E_total_imag * E_total_imag));
            }
            
            drawPolarPlot(patternData);
            
            if (selectedAngleRad !== null) {
                analyzePoint(selectedAngleRad);
                drawVectorSum(selectedAngleRad);
            } else {
                totalEfieldSpan.textContent = '0';
                totalEfieldRealSpan.textContent = '0';
                individualEfieldsDiv.innerHTML = '';
                vectorSumCtx.clearRect(0, 0, vectorSumCanvas.width, vectorSumCanvas.height);
            }
        }

        function analyzePoint(angleRad) {
            const N = parseInt(antennaCountInput.value);
            const betaDeg = parseFloat(phaseDifferenceInput.value) || 0;
            const freqHz = parseFloat(frequencyInput.value) * 1e6 || 0;

            const lambda = freqHz > 0 ? c / freqHz : 0;
            const d = (betaDeg / 360) * lambda;
            const k = freqHz > 0 ? 2 * Math.PI / lambda : 0;

            let totalE_real = 0;
            let totalE_imag = 0;
            let totalE_real_sum = 0;
            let individualEfieldsHtml = '';

            const theta = angleRad;
            const thetaDeg = (angleRad * 180 / Math.PI).toFixed(2);

            for (let n = 0; n < N; n++) {
                const currentMag = parseFloat(currentTableBody.children[n].querySelector('.current-mag').value) || 0;
                const currentPhaseRad = (parseFloat(currentTableBody.children[n].querySelector('.current-phase').value) || 0) * Math.PI / 180;
                const currentPhaseDeg = (currentPhaseRad * 180 / Math.PI).toFixed(2);

                const zn = (n - (N - 1) / 2) * d;
                const phaseTermRad = k * zn * Math.cos(theta) + currentPhaseRad;
                const phaseTermDeg = (phaseTermRad * 180 / Math.PI).toFixed(2);

                const E_real = currentMag * Math.cos(phaseTermRad);
                const E_imag = currentMag * Math.sin(phaseTermRad);
                
                const E_mag = Math.sqrt(E_real*E_real + E_imag*E_imag);
                const E_phaseDeg = Math.atan2(E_imag, E_real) * 180 / Math.PI;

                totalE_real += E_real;
                totalE_imag += E_imag;
                totalE_real_sum += E_real;

                individualEfieldsHtml += `
                    <p>
                        <b>안테나 ${n + 1} ($E_{n+1}$):</b>
                        <br>
                        <span class="math-expr">
                            $$E_{${n+1}} = |I_{${n+1}}| \\times e^{j(\\text{전류 위상} + k z_{${n+1}} cos\\theta)}$$
                            $$E_{${n+1}} = ${currentMag.toFixed(3)} \\times e^{j(${currentPhaseDeg}° + (${k.toFixed(3)} \\times ${zn.toFixed(3)} \\times cos(${thetaDeg}°)))°} = ${currentMag.toFixed(3)} \\times e^{j(${E_phaseDeg.toFixed(2)})°}$$
                        </span>
                        <br>
                        <b>[시뮬레이터 계산]</b> 크기: $|E_{${n+1}}| = |I_{${n+1}}|$ = ${E_mag.toFixed(3)}, 위상: ${E_phaseDeg.toFixed(2)}°
                        <br>
                        <b>[수업 계산]</b> 실수부 크기: $|E_{real}| = |${E_real.toFixed(3)}|$
                    </p>
                `;
            }

            const totalE_mag = Math.sqrt(totalE_real * totalE_real + totalE_imag * totalE_imag);
            totalEfieldSpan.textContent = totalE_mag.toFixed(3);
            totalEfieldRealSpan.textContent = Math.abs(totalE_real_sum).toFixed(3);
            individualEfieldsDiv.innerHTML = individualEfieldsHtml;
            MathJax.Hub.Queue(["Typeset",MathJax.Hub,individualEfieldsDiv]);
        }

        function updatePattern() {
            antennaCountValue.textContent = antennaCountInput.value;
            calculateAndDrawPattern();
        }

        // 이벤트 리스너
        antennaCountInput.addEventListener('input', updateCurrentTable);
        phaseDifferenceInput.addEventListener('input', updatePattern);
        frequencyInput.addEventListener('input', updatePattern);
        updatePointBtn.addEventListener('click', () => {
            const angleDeg = parseFloat(selectedPointInput.value);
            if (!isNaN(angleDeg)) {
                selectedAngleRad = (angleDeg * Math.PI / 180);
                updatePattern();
            }
        });
        
        radiationPatternCanvas.addEventListener('click', (e) => {
            const rect = radiationPatternCanvas.getBoundingClientRect();
            const centerX = radiationPatternCanvas.width / 2;
            const centerY = radiationPatternCanvas.height / 2;
            const x = e.clientX - rect.left - centerX;
            const y = e.clientY - rect.top - centerY;
            
            let angleRad = Math.atan2(-y, x);
            if (angleRad < 0) {
                angleRad += 2 * Math.PI;
            }
            
            selectedAngleRad = angleRad;
            const angleDeg = selectedAngleRad * 180 / Math.PI;
            selectedPointInput.value = angleDeg.toFixed(2);
            updatePattern();
        });

        // 초기 실행
        updateCurrentTable();
        calculateAndDrawPattern();
    </script>
</body>
</html>
